
/**
 * @file check.c
 *
 * Functions needed by check.
 * 
 * THIS FILE HAS BEEN GENERATED USING 
 * $Id: check.c.xsl 14618 2006-02-28 16:08:17Z                                jhb $.
 * DO NOT EDIT THIS FILE AS MIGHT BE CHANGED IN A LATER VERSION.
 *
 * ALL CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN!
 *
 */

/**
 * @defgroup check Check tree Functions
 *
 * Functions needed by check traversal.
 *
 * @{
 */


#include "check.h"
#include "globals.h"
#include "tree_basic.h"
#include "traverse.h"
#include "dbug.h"
#include "print.h"
#include "check_lib.h"
#include "free.h"
#include "str.h"
#include "memory.h"

/*****************************************************************************
 *
 * @fn node *CHKdoTreeCheck( node *syntax_tree)
 *
 ****************************************************************************/
node *
CHKdoTreeCheck (node * syntax_tree)
{
  DBUG_ENTER ("CHKdoTreeCheck");

  DBUG_PRINT ("CHK", ("Starting the check mechanism"));

  TRAVpush (TR_chk);
  syntax_tree = TRAVdo (syntax_tree, NULL);
  TRAVpop ();

  DBUG_PRINT ("CHK", ("Checkmechanism complete"));

  DBUG_RETURN (syntax_tree);
}

static bool
isDecl (node * arg_node)
{
  bool res = ((NODE_TYPE (arg_node) == N_fundef) ||
	      (NODE_TYPE (arg_node) == N_globdecl) ||
	      (NODE_TYPE (arg_node) == N_globdef));
  return (res);
}

static bool
isExpr (node * arg_node)
{
  bool res = ((NODE_TYPE (arg_node) == N_arrexpr) ||
	      (NODE_TYPE (arg_node) == N_binop) ||
	      (NODE_TYPE (arg_node) == N_bool) ||
	      (NODE_TYPE (arg_node) == N_cast) ||
	      (NODE_TYPE (arg_node) == N_float) ||
	      (NODE_TYPE (arg_node) == N_funcall) ||
	      (NODE_TYPE (arg_node) == N_monop) ||
	      (NODE_TYPE (arg_node) == N_num) ||
	      (NODE_TYPE (arg_node) == N_var));
  return (res);
}

static bool
isStmt (node * arg_node)
{
  bool res = ((NODE_TYPE (arg_node) == N_assign) ||
	      (NODE_TYPE (arg_node) == N_dowhile) ||
	      (NODE_TYPE (arg_node) == N_exprstmt) ||
	      (NODE_TYPE (arg_node) == N_for) ||
	      (NODE_TYPE (arg_node) == N_ifelse) ||
	      (NODE_TYPE (arg_node) == N_return) ||
	      (NODE_TYPE (arg_node) == N_while));
  return (res);
}

void
isDummy ()
{
  isDecl (NULL);
  isExpr (NULL);
  isStmt (NULL);
}

/** <!--******************************************************************-->
 *
 * @fn CHKarrexpr
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node ArrExpr node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKarrexpr (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKarrexpr");

/*
 * Son check: ARREXPR_EXPRS 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (ARREXPR_EXPRS (arg_node), arg_node,
		   "mandatory son ARREXPR_EXPRS is NULL");
      if (ARREXPR_EXPRS (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (ARREXPR_EXPRS (arg_node)) == N_exprs)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "ARREXPR_EXPRS hasnt the right type."
					 " It should be: " "N_exprs");
	    }
	}
    }
  else
    {
      CHKnotExist (ARREXPR_EXPRS (arg_node), arg_node,
		   "attribute ARREXPR_EXPRS must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (ARREXPR_EXPRS (arg_node) != NULL)
    {
      ARREXPR_EXPRS (arg_node) = TRAVdo (ARREXPR_EXPRS (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKassign
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Assign node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKassign (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKassign");

/*
 * Son check: ASSIGN_EXPR 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (ASSIGN_EXPR (arg_node), arg_node,
		   "mandatory son ASSIGN_EXPR is NULL");
      if (ASSIGN_EXPR (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (ASSIGN_EXPR (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "ASSIGN_EXPR hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (ASSIGN_EXPR (arg_node), arg_node,
		   "attribute ASSIGN_EXPR must be NULL");
    }

/*
 * Son check: ASSIGN_LET 
 */
  if ((FALSE) || (TRUE))
    {
      if (ASSIGN_LET (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (ASSIGN_LET (arg_node)) == N_varlet)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "ASSIGN_LET hasnt the right type."
					 " It should be: " "N_varlet");
	    }
	}
    }
  else
    {
      CHKnotExist (ASSIGN_LET (arg_node), arg_node,
		   "attribute ASSIGN_LET must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (ASSIGN_EXPR (arg_node) != NULL)
    {
      ASSIGN_EXPR (arg_node) = TRAVdo (ASSIGN_EXPR (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (ASSIGN_LET (arg_node) != NULL)
    {
      ASSIGN_LET (arg_node) = TRAVdo (ASSIGN_LET (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKbinop
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node BinOp node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKbinop (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKbinop");

/*
 * Son check: BINOP_LEFT 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (BINOP_LEFT (arg_node), arg_node,
		   "mandatory son BINOP_LEFT is NULL");
      if (BINOP_LEFT (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (BINOP_LEFT (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "BINOP_LEFT hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (BINOP_LEFT (arg_node), arg_node,
		   "attribute BINOP_LEFT must be NULL");
    }

/*
 * Son check: BINOP_RIGHT 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (BINOP_RIGHT (arg_node), arg_node,
		   "mandatory son BINOP_RIGHT is NULL");
      if (BINOP_RIGHT (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (BINOP_RIGHT (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "BINOP_RIGHT hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (BINOP_RIGHT (arg_node), arg_node,
		   "attribute BINOP_RIGHT must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (BINOP_LEFT (arg_node) != NULL)
    {
      BINOP_LEFT (arg_node) = TRAVdo (BINOP_LEFT (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (BINOP_RIGHT (arg_node) != NULL)
    {
      BINOP_RIGHT (arg_node) = TRAVdo (BINOP_RIGHT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKbool
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Bool node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKbool (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKbool");
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKcast
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Cast node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKcast (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKcast");

/*
 * Son check: CAST_EXPR 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (CAST_EXPR (arg_node), arg_node,
		   "mandatory son CAST_EXPR is NULL");
      if (CAST_EXPR (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (CAST_EXPR (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "CAST_EXPR hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (CAST_EXPR (arg_node), arg_node,
		   "attribute CAST_EXPR must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (CAST_EXPR (arg_node) != NULL)
    {
      CAST_EXPR (arg_node) = TRAVdo (CAST_EXPR (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKdecls
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Decls node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKdecls (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKdecls");

/*
 * Son check: DECLS_DECL 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (DECLS_DECL (arg_node), arg_node,
		   "mandatory son DECLS_DECL is NULL");
      if (DECLS_DECL (arg_node) != NULL)
	{
	  if (!((FALSE) || (isDecl (DECLS_DECL (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "DECLS_DECL hasnt the right type."
					 " It should be: " "Nodeset: Decl");
	    }
	}
    }
  else
    {
      CHKnotExist (DECLS_DECL (arg_node), arg_node,
		   "attribute DECLS_DECL must be NULL");
    }

/*
 * Son check: DECLS_NEXT 
 */
  if ((FALSE) || (TRUE))
    {
      if (DECLS_NEXT (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (DECLS_NEXT (arg_node)) == N_decls)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "DECLS_NEXT hasnt the right type."
					 " It should be: " "N_decls");
	    }
	}
    }
  else
    {
      CHKnotExist (DECLS_NEXT (arg_node), arg_node,
		   "attribute DECLS_NEXT must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (DECLS_DECL (arg_node) != NULL)
    {
      DECLS_DECL (arg_node) = TRAVdo (DECLS_DECL (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (DECLS_NEXT (arg_node) != NULL)
    {
      DECLS_NEXT (arg_node) = TRAVdo (DECLS_NEXT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKdowhile
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node DoWhile node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKdowhile (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKdowhile");

/*
 * Son check: DOWHILE_BLOCK 
 */
  if ((FALSE) || (TRUE))
    {
      if (DOWHILE_BLOCK (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (DOWHILE_BLOCK (arg_node)) == N_stmts)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "DOWHILE_BLOCK hasnt the right type."
					 " It should be: " "N_stmts");
	    }
	}
    }
  else
    {
      CHKnotExist (DOWHILE_BLOCK (arg_node), arg_node,
		   "attribute DOWHILE_BLOCK must be NULL");
    }

/*
 * Son check: DOWHILE_COND 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (DOWHILE_COND (arg_node), arg_node,
		   "mandatory son DOWHILE_COND is NULL");
      if (DOWHILE_COND (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (DOWHILE_COND (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "DOWHILE_COND hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (DOWHILE_COND (arg_node), arg_node,
		   "attribute DOWHILE_COND must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (DOWHILE_BLOCK (arg_node) != NULL)
    {
      DOWHILE_BLOCK (arg_node) = TRAVdo (DOWHILE_BLOCK (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (DOWHILE_COND (arg_node) != NULL)
    {
      DOWHILE_COND (arg_node) = TRAVdo (DOWHILE_COND (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKerror
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Error node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKerror (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKerror");

/*
 * Son check: ERROR_NEXT 
 */
  if ((FALSE) || (TRUE))
    {
      if (ERROR_NEXT (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (ERROR_NEXT (arg_node)) == N_error)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "ERROR_NEXT hasnt the right type."
					 " It should be: " "N_error");
	    }
	}
    }
  else
    {
      CHKnotExist (ERROR_NEXT (arg_node), arg_node,
		   "attribute ERROR_NEXT must be NULL");
    }

/*
 * Attribute check: ERROR_MESSAGE
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (ERROR_MESSAGE (arg_node), arg_node,
			 "mandatory attribute ERROR_MESSAGE is NULL");
    }
  else
    {
      CHKnotExist (ERROR_MESSAGE (arg_node), arg_node,
		   "attribute ERROR_MESSAGE must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (ERROR_NEXT (arg_node) != NULL)
    {
      ERROR_NEXT (arg_node) = TRAVdo (ERROR_NEXT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKexprstmt
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node ExprStmt node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKexprstmt (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKexprstmt");

/*
 * Son check: EXPRSTMT_EXPR 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (EXPRSTMT_EXPR (arg_node), arg_node,
		   "mandatory son EXPRSTMT_EXPR is NULL");
      if (EXPRSTMT_EXPR (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (EXPRSTMT_EXPR (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "EXPRSTMT_EXPR hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (EXPRSTMT_EXPR (arg_node), arg_node,
		   "attribute EXPRSTMT_EXPR must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (EXPRSTMT_EXPR (arg_node) != NULL)
    {
      EXPRSTMT_EXPR (arg_node) = TRAVdo (EXPRSTMT_EXPR (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKexprs
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Exprs node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKexprs (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKexprs");

/*
 * Son check: EXPRS_EXPR 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (EXPRS_EXPR (arg_node), arg_node,
		   "mandatory son EXPRS_EXPR is NULL");
      if (EXPRS_EXPR (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (EXPRS_EXPR (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "EXPRS_EXPR hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (EXPRS_EXPR (arg_node), arg_node,
		   "attribute EXPRS_EXPR must be NULL");
    }

/*
 * Son check: EXPRS_NEXT 
 */
  if ((FALSE) || (TRUE))
    {
      if (EXPRS_NEXT (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (EXPRS_NEXT (arg_node)) == N_exprs)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "EXPRS_NEXT hasnt the right type."
					 " It should be: " "N_exprs");
	    }
	}
    }
  else
    {
      CHKnotExist (EXPRS_NEXT (arg_node), arg_node,
		   "attribute EXPRS_NEXT must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (EXPRS_EXPR (arg_node) != NULL)
    {
      EXPRS_EXPR (arg_node) = TRAVdo (EXPRS_EXPR (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (EXPRS_NEXT (arg_node) != NULL)
    {
      EXPRS_NEXT (arg_node) = TRAVdo (EXPRS_NEXT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKfloat
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Float node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKfloat (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKfloat");
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKfor
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node For node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKfor (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKfor");

/*
 * Son check: FOR_BLOCK 
 */
  if ((FALSE) || (TRUE))
    {
      if (FOR_BLOCK (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (FOR_BLOCK (arg_node)) == N_stmts)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FOR_BLOCK hasnt the right type."
					 " It should be: " "N_stmts");
	    }
	}
    }
  else
    {
      CHKnotExist (FOR_BLOCK (arg_node), arg_node,
		   "attribute FOR_BLOCK must be NULL");
    }

/*
 * Son check: FOR_START 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (FOR_START (arg_node), arg_node,
		   "mandatory son FOR_START is NULL");
      if (FOR_START (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (FOR_START (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FOR_START hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (FOR_START (arg_node), arg_node,
		   "attribute FOR_START must be NULL");
    }

/*
 * Son check: FOR_STEP 
 */
  if ((FALSE) || (TRUE))
    {
      if (FOR_STEP (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (FOR_STEP (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FOR_STEP hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (FOR_STEP (arg_node), arg_node,
		   "attribute FOR_STEP must be NULL");
    }

/*
 * Son check: FOR_STOP 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (FOR_STOP (arg_node), arg_node,
		   "mandatory son FOR_STOP is NULL");
      if (FOR_STOP (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (FOR_STOP (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FOR_STOP hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (FOR_STOP (arg_node), arg_node,
		   "attribute FOR_STOP must be NULL");
    }

/*
 * Attribute check: FOR_LOOPVAR
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (FOR_LOOPVAR (arg_node), arg_node,
			 "mandatory attribute FOR_LOOPVAR is NULL");
    }
  else
    {
      CHKnotExist (FOR_LOOPVAR (arg_node), arg_node,
		   "attribute FOR_LOOPVAR must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (FOR_BLOCK (arg_node) != NULL)
    {
      FOR_BLOCK (arg_node) = TRAVdo (FOR_BLOCK (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FOR_START (arg_node) != NULL)
    {
      FOR_START (arg_node) = TRAVdo (FOR_START (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FOR_STEP (arg_node) != NULL)
    {
      FOR_STEP (arg_node) = TRAVdo (FOR_STEP (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FOR_STOP (arg_node) != NULL)
    {
      FOR_STOP (arg_node) = TRAVdo (FOR_STOP (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKfunbody
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node FunBody node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKfunbody (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKfunbody");

/*
 * Son check: FUNBODY_LOCALFUNDEFS 
 */
  if ((FALSE) || (TRUE))
    {
      if (FUNBODY_LOCALFUNDEFS (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (FUNBODY_LOCALFUNDEFS (arg_node)) == N_fundefs)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNBODY_LOCALFUNDEFS hasnt the right type."
					 " It should be: " "N_fundefs");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNBODY_LOCALFUNDEFS (arg_node), arg_node,
		   "attribute FUNBODY_LOCALFUNDEFS must be NULL");
    }

/*
 * Son check: FUNBODY_STMTS 
 */
  if ((FALSE) || (TRUE))
    {
      if (FUNBODY_STMTS (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (FUNBODY_STMTS (arg_node)) == N_stmts)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNBODY_STMTS hasnt the right type."
					 " It should be: " "N_stmts");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNBODY_STMTS (arg_node), arg_node,
		   "attribute FUNBODY_STMTS must be NULL");
    }

/*
 * Son check: FUNBODY_VARDECLS 
 */
  if ((FALSE) || (TRUE))
    {
      if (FUNBODY_VARDECLS (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (FUNBODY_VARDECLS (arg_node)) == N_vardecl)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNBODY_VARDECLS hasnt the right type."
					 " It should be: " "N_vardecl");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNBODY_VARDECLS (arg_node), arg_node,
		   "attribute FUNBODY_VARDECLS must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (FUNBODY_LOCALFUNDEFS (arg_node) != NULL)
    {
      FUNBODY_LOCALFUNDEFS (arg_node) =
	TRAVdo (FUNBODY_LOCALFUNDEFS (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FUNBODY_STMTS (arg_node) != NULL)
    {
      FUNBODY_STMTS (arg_node) = TRAVdo (FUNBODY_STMTS (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FUNBODY_VARDECLS (arg_node) != NULL)
    {
      FUNBODY_VARDECLS (arg_node) =
	TRAVdo (FUNBODY_VARDECLS (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKfuncall
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node FunCall node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKfuncall (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKfuncall");

/*
 * Son check: FUNCALL_ARGS 
 */
  if ((FALSE) || (TRUE))
    {
      if (FUNCALL_ARGS (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (FUNCALL_ARGS (arg_node)) == N_exprs)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNCALL_ARGS hasnt the right type."
					 " It should be: " "N_exprs");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNCALL_ARGS (arg_node), arg_node,
		   "attribute FUNCALL_ARGS must be NULL");
    }

/*
 * Attribute check: FUNCALL_DECL
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (FUNCALL_DECL (arg_node), arg_node,
			 "mandatory attribute FUNCALL_DECL is NULL");
    }
  else
    {
      CHKnotExist (FUNCALL_DECL (arg_node), arg_node,
		   "attribute FUNCALL_DECL must be NULL");
    }

/*
 * Attribute check: FUNCALL_NAME
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (FUNCALL_NAME (arg_node), arg_node,
			 "mandatory attribute FUNCALL_NAME is NULL");
    }
  else
    {
      CHKnotExist (FUNCALL_NAME (arg_node), arg_node,
		   "attribute FUNCALL_NAME must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (FUNCALL_ARGS (arg_node) != NULL)
    {
      FUNCALL_ARGS (arg_node) = TRAVdo (FUNCALL_ARGS (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKfundef
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node FunDef node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKfundef (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKfundef");

/*
 * Son check: FUNDEF_FUNBODY 
 */
  if ((FALSE) || (TRUE))
    {
      if (FUNDEF_FUNBODY (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (FUNDEF_FUNBODY (arg_node)) == N_funbody)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNDEF_FUNBODY hasnt the right type."
					 " It should be: " "N_funbody");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNDEF_FUNBODY (arg_node), arg_node,
		   "attribute FUNDEF_FUNBODY must be NULL");
    }

/*
 * Son check: FUNDEF_PARAMS 
 */
  if ((FALSE) || (TRUE))
    {
      if (FUNDEF_PARAMS (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (FUNDEF_PARAMS (arg_node)) == N_param)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNDEF_PARAMS hasnt the right type."
					 " It should be: " "N_param");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNDEF_PARAMS (arg_node), arg_node,
		   "attribute FUNDEF_PARAMS must be NULL");
    }

/*
 * Attribute check: FUNDEF_NAME
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (FUNDEF_NAME (arg_node), arg_node,
			 "mandatory attribute FUNDEF_NAME is NULL");
    }
  else
    {
      CHKnotExist (FUNDEF_NAME (arg_node), arg_node,
		   "attribute FUNDEF_NAME must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (FUNDEF_FUNBODY (arg_node) != NULL)
    {
      FUNDEF_FUNBODY (arg_node) =
	TRAVdo (FUNDEF_FUNBODY (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FUNDEF_PARAMS (arg_node) != NULL)
    {
      FUNDEF_PARAMS (arg_node) = TRAVdo (FUNDEF_PARAMS (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKfundefs
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node FunDefs node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKfundefs (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKfundefs");

/*
 * Son check: FUNDEFS_FUNDEF 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (FUNDEFS_FUNDEF (arg_node), arg_node,
		   "mandatory son FUNDEFS_FUNDEF is NULL");
      if (FUNDEFS_FUNDEF (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (FUNDEFS_FUNDEF (arg_node)) == N_fundef)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNDEFS_FUNDEF hasnt the right type."
					 " It should be: " "N_fundef");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNDEFS_FUNDEF (arg_node), arg_node,
		   "attribute FUNDEFS_FUNDEF must be NULL");
    }

/*
 * Son check: FUNDEFS_NEXT 
 */
  if ((FALSE) || (TRUE))
    {
      if (FUNDEFS_NEXT (arg_node) != NULL)
	{
	  if (!
	      ((FALSE) || (NODE_TYPE (FUNDEFS_NEXT (arg_node)) == N_fundefs)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNDEFS_NEXT hasnt the right type."
					 " It should be: " "N_fundefs");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNDEFS_NEXT (arg_node), arg_node,
		   "attribute FUNDEFS_NEXT must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (FUNDEFS_FUNDEF (arg_node) != NULL)
    {
      FUNDEFS_FUNDEF (arg_node) =
	TRAVdo (FUNDEFS_FUNDEF (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FUNDEFS_NEXT (arg_node) != NULL)
    {
      FUNDEFS_NEXT (arg_node) = TRAVdo (FUNDEFS_NEXT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKglobdecl
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node GlobDecl node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKglobdecl (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKglobdecl");

/*
 * Son check: GLOBDECL_DIMS 
 */
  if ((FALSE) || (TRUE))
    {
      if (GLOBDECL_DIMS (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (GLOBDECL_DIMS (arg_node)) == N_ids)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "GLOBDECL_DIMS hasnt the right type."
					 " It should be: " "N_ids");
	    }
	}
    }
  else
    {
      CHKnotExist (GLOBDECL_DIMS (arg_node), arg_node,
		   "attribute GLOBDECL_DIMS must be NULL");
    }

/*
 * Attribute check: GLOBDECL_NAME
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (GLOBDECL_NAME (arg_node), arg_node,
			 "mandatory attribute GLOBDECL_NAME is NULL");
    }
  else
    {
      CHKnotExist (GLOBDECL_NAME (arg_node), arg_node,
		   "attribute GLOBDECL_NAME must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (GLOBDECL_DIMS (arg_node) != NULL)
    {
      GLOBDECL_DIMS (arg_node) = TRAVdo (GLOBDECL_DIMS (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKglobdef
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node GlobDef node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKglobdef (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKglobdef");

/*
 * Son check: GLOBDEF_DIMS 
 */
  if ((FALSE) || (TRUE))
    {
      if (GLOBDEF_DIMS (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (GLOBDEF_DIMS (arg_node)) == N_exprs)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "GLOBDEF_DIMS hasnt the right type."
					 " It should be: " "N_exprs");
	    }
	}
    }
  else
    {
      CHKnotExist (GLOBDEF_DIMS (arg_node), arg_node,
		   "attribute GLOBDEF_DIMS must be NULL");
    }

/*
 * Son check: GLOBDEF_INIT 
 */
  if ((FALSE) || (TRUE))
    {
      if (GLOBDEF_INIT (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (GLOBDEF_INIT (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "GLOBDEF_INIT hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (GLOBDEF_INIT (arg_node), arg_node,
		   "attribute GLOBDEF_INIT must be NULL");
    }

/*
 * Attribute check: GLOBDEF_NAME
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (GLOBDEF_NAME (arg_node), arg_node,
			 "mandatory attribute GLOBDEF_NAME is NULL");
    }
  else
    {
      CHKnotExist (GLOBDEF_NAME (arg_node), arg_node,
		   "attribute GLOBDEF_NAME must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (GLOBDEF_DIMS (arg_node) != NULL)
    {
      GLOBDEF_DIMS (arg_node) = TRAVdo (GLOBDEF_DIMS (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (GLOBDEF_INIT (arg_node) != NULL)
    {
      GLOBDEF_INIT (arg_node) = TRAVdo (GLOBDEF_INIT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKids
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Ids node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKids (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKids");

/*
 * Son check: IDS_NEXT 
 */
  if ((FALSE) || (TRUE))
    {
      if (IDS_NEXT (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (IDS_NEXT (arg_node)) == N_ids)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "IDS_NEXT hasnt the right type."
					 " It should be: " "N_ids");
	    }
	}
    }
  else
    {
      CHKnotExist (IDS_NEXT (arg_node), arg_node,
		   "attribute IDS_NEXT must be NULL");
    }

/*
 * Attribute check: IDS_NAME
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (IDS_NAME (arg_node), arg_node,
			 "mandatory attribute IDS_NAME is NULL");
    }
  else
    {
      CHKnotExist (IDS_NAME (arg_node), arg_node,
		   "attribute IDS_NAME must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (IDS_NEXT (arg_node) != NULL)
    {
      IDS_NEXT (arg_node) = TRAVdo (IDS_NEXT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKifelse
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node IfElse node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKifelse (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKifelse");

/*
 * Son check: IFELSE_COND 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (IFELSE_COND (arg_node), arg_node,
		   "mandatory son IFELSE_COND is NULL");
      if (IFELSE_COND (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (IFELSE_COND (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "IFELSE_COND hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (IFELSE_COND (arg_node), arg_node,
		   "attribute IFELSE_COND must be NULL");
    }

/*
 * Son check: IFELSE_ELSE 
 */
  if ((FALSE) || (TRUE))
    {
      if (IFELSE_ELSE (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (IFELSE_ELSE (arg_node)) == N_stmts)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "IFELSE_ELSE hasnt the right type."
					 " It should be: " "N_stmts");
	    }
	}
    }
  else
    {
      CHKnotExist (IFELSE_ELSE (arg_node), arg_node,
		   "attribute IFELSE_ELSE must be NULL");
    }

/*
 * Son check: IFELSE_THEN 
 */
  if ((FALSE) || (TRUE))
    {
      if (IFELSE_THEN (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (IFELSE_THEN (arg_node)) == N_stmts)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "IFELSE_THEN hasnt the right type."
					 " It should be: " "N_stmts");
	    }
	}
    }
  else
    {
      CHKnotExist (IFELSE_THEN (arg_node), arg_node,
		   "attribute IFELSE_THEN must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (IFELSE_COND (arg_node) != NULL)
    {
      IFELSE_COND (arg_node) = TRAVdo (IFELSE_COND (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (IFELSE_ELSE (arg_node) != NULL)
    {
      IFELSE_ELSE (arg_node) = TRAVdo (IFELSE_ELSE (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (IFELSE_THEN (arg_node) != NULL)
    {
      IFELSE_THEN (arg_node) = TRAVdo (IFELSE_THEN (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKmonop
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node MonOp node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKmonop (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKmonop");

/*
 * Son check: MONOP_OPERAND 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (MONOP_OPERAND (arg_node), arg_node,
		   "mandatory son MONOP_OPERAND is NULL");
      if (MONOP_OPERAND (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (MONOP_OPERAND (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "MONOP_OPERAND hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (MONOP_OPERAND (arg_node), arg_node,
		   "attribute MONOP_OPERAND must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (MONOP_OPERAND (arg_node) != NULL)
    {
      MONOP_OPERAND (arg_node) = TRAVdo (MONOP_OPERAND (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKnum
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Num node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKnum (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKnum");
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKparam
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Param node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKparam (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKparam");

/*
 * Son check: PARAM_DIMS 
 */
  if ((FALSE) || (TRUE))
    {
      if (PARAM_DIMS (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (PARAM_DIMS (arg_node)) == N_ids)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "PARAM_DIMS hasnt the right type."
					 " It should be: " "N_ids");
	    }
	}
    }
  else
    {
      CHKnotExist (PARAM_DIMS (arg_node), arg_node,
		   "attribute PARAM_DIMS must be NULL");
    }

/*
 * Son check: PARAM_NEXT 
 */
  if ((FALSE) || (TRUE))
    {
      if (PARAM_NEXT (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (PARAM_NEXT (arg_node)) == N_param)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "PARAM_NEXT hasnt the right type."
					 " It should be: " "N_param");
	    }
	}
    }
  else
    {
      CHKnotExist (PARAM_NEXT (arg_node), arg_node,
		   "attribute PARAM_NEXT must be NULL");
    }

/*
 * Attribute check: PARAM_NAME
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (PARAM_NAME (arg_node), arg_node,
			 "mandatory attribute PARAM_NAME is NULL");
    }
  else
    {
      CHKnotExist (PARAM_NAME (arg_node), arg_node,
		   "attribute PARAM_NAME must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (PARAM_DIMS (arg_node) != NULL)
    {
      PARAM_DIMS (arg_node) = TRAVdo (PARAM_DIMS (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (PARAM_NEXT (arg_node) != NULL)
    {
      PARAM_NEXT (arg_node) = TRAVdo (PARAM_NEXT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKprogram
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Program node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKprogram (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKprogram");

/*
 * Son check: PROGRAM_DECLS 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (PROGRAM_DECLS (arg_node), arg_node,
		   "mandatory son PROGRAM_DECLS is NULL");
      if (PROGRAM_DECLS (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (PROGRAM_DECLS (arg_node)) == N_decls)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "PROGRAM_DECLS hasnt the right type."
					 " It should be: " "N_decls");
	    }
	}
    }
  else
    {
      CHKnotExist (PROGRAM_DECLS (arg_node), arg_node,
		   "attribute PROGRAM_DECLS must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (PROGRAM_DECLS (arg_node) != NULL)
    {
      PROGRAM_DECLS (arg_node) = TRAVdo (PROGRAM_DECLS (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKreturn
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Return node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKreturn (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKreturn");

/*
 * Son check: RETURN_EXPR 
 */
  if ((FALSE) || (TRUE))
    {
      if (RETURN_EXPR (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (RETURN_EXPR (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "RETURN_EXPR hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (RETURN_EXPR (arg_node), arg_node,
		   "attribute RETURN_EXPR must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (RETURN_EXPR (arg_node) != NULL)
    {
      RETURN_EXPR (arg_node) = TRAVdo (RETURN_EXPR (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKstmts
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Stmts node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKstmts (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKstmts");

/*
 * Son check: STMTS_NEXT 
 */
  if ((FALSE) || (TRUE))
    {
      if (STMTS_NEXT (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (STMTS_NEXT (arg_node)) == N_stmts)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "STMTS_NEXT hasnt the right type."
					 " It should be: " "N_stmts");
	    }
	}
    }
  else
    {
      CHKnotExist (STMTS_NEXT (arg_node), arg_node,
		   "attribute STMTS_NEXT must be NULL");
    }

/*
 * Son check: STMTS_STMT 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (STMTS_STMT (arg_node), arg_node,
		   "mandatory son STMTS_STMT is NULL");
      if (STMTS_STMT (arg_node) != NULL)
	{
	  if (!((FALSE) || (isStmt (STMTS_STMT (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "STMTS_STMT hasnt the right type."
					 " It should be: " "Nodeset: Stmt");
	    }
	}
    }
  else
    {
      CHKnotExist (STMTS_STMT (arg_node), arg_node,
		   "attribute STMTS_STMT must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (STMTS_NEXT (arg_node) != NULL)
    {
      STMTS_NEXT (arg_node) = TRAVdo (STMTS_NEXT (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (STMTS_STMT (arg_node) != NULL)
    {
      STMTS_STMT (arg_node) = TRAVdo (STMTS_STMT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKsymboltable
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node SymbolTable node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKsymboltable (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKsymboltable");

/*
 * Son check: SYMBOLTABLE_ENTRY 
 */
  if ((FALSE) || (TRUE))
    {
      if (SYMBOLTABLE_ENTRY (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (SYMBOLTABLE_ENTRY (arg_node)) ==
		   N_symboltableentry)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "SYMBOLTABLE_ENTRY hasnt the right type."
					 " It should be: "
					 "N_symboltableentry");
	    }
	}
    }
  else
    {
      CHKnotExist (SYMBOLTABLE_ENTRY (arg_node), arg_node,
		   "attribute SYMBOLTABLE_ENTRY must be NULL");
    }

/*
 * Attribute check: SYMBOLTABLE_PARENT
 */
  if ((FALSE) || (TRUE))
    {
    }
  else
    {
      CHKnotExist (SYMBOLTABLE_PARENT (arg_node), arg_node,
		   "attribute SYMBOLTABLE_PARENT must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (SYMBOLTABLE_ENTRY (arg_node) != NULL)
    {
      SYMBOLTABLE_ENTRY (arg_node) =
	TRAVdo (SYMBOLTABLE_ENTRY (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKsymboltableentry
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node SymbolTableEntry node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKsymboltableentry (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKsymboltableentry");

/*
 * Son check: SYMBOLTABLEENTRY_NEXT 
 */
  if ((FALSE) || (TRUE))
    {
      if (SYMBOLTABLEENTRY_NEXT (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (SYMBOLTABLEENTRY_NEXT (arg_node)) ==
		   N_symboltableentry)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "SYMBOLTABLEENTRY_NEXT hasnt the right type."
					 " It should be: "
					 "N_symboltableentry");
	    }
	}
    }
  else
    {
      CHKnotExist (SYMBOLTABLEENTRY_NEXT (arg_node), arg_node,
		   "attribute SYMBOLTABLEENTRY_NEXT must be NULL");
    }

/*
 * Son check: SYMBOLTABLEENTRY_TABLE 
 */
  if ((FALSE) || (TRUE))
    {
      if (SYMBOLTABLEENTRY_TABLE (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (SYMBOLTABLEENTRY_TABLE (arg_node)) ==
		   N_symboltable)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "SYMBOLTABLEENTRY_TABLE hasnt the right type."
					 " It should be: " "N_symboltable");
	    }
	}
    }
  else
    {
      CHKnotExist (SYMBOLTABLEENTRY_TABLE (arg_node), arg_node,
		   "attribute SYMBOLTABLEENTRY_TABLE must be NULL");
    }

/*
 * Attribute check: SYMBOLTABLEENTRY_NAME
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (SYMBOLTABLEENTRY_NAME (arg_node), arg_node,
			 "mandatory attribute SYMBOLTABLEENTRY_NAME is NULL");
    }
  else
    {
      CHKnotExist (SYMBOLTABLEENTRY_NAME (arg_node), arg_node,
		   "attribute SYMBOLTABLEENTRY_NAME must be NULL");
    }

/*
 * Attribute check: SYMBOLTABLEENTRY_NODE
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (SYMBOLTABLEENTRY_NODE (arg_node), arg_node,
			 "mandatory attribute SYMBOLTABLEENTRY_NODE is NULL");
    }
  else
    {
      CHKnotExist (SYMBOLTABLEENTRY_NODE (arg_node), arg_node,
		   "attribute SYMBOLTABLEENTRY_NODE must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (SYMBOLTABLEENTRY_NEXT (arg_node) != NULL)
    {
      SYMBOLTABLEENTRY_NEXT (arg_node) =
	TRAVdo (SYMBOLTABLEENTRY_NEXT (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (SYMBOLTABLEENTRY_TABLE (arg_node) != NULL)
    {
      SYMBOLTABLEENTRY_TABLE (arg_node) =
	TRAVdo (SYMBOLTABLEENTRY_TABLE (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKvar
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Var node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKvar (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKvar");

/*
 * Son check: VAR_INDICES 
 */
  if ((FALSE) || (TRUE))
    {
      if (VAR_INDICES (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (VAR_INDICES (arg_node)) == N_exprs)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "VAR_INDICES hasnt the right type."
					 " It should be: " "N_exprs");
	    }
	}
    }
  else
    {
      CHKnotExist (VAR_INDICES (arg_node), arg_node,
		   "attribute VAR_INDICES must be NULL");
    }

/*
 * Attribute check: VAR_DECL
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (VAR_DECL (arg_node), arg_node,
			 "mandatory attribute VAR_DECL is NULL");
    }
  else
    {
      CHKnotExist (VAR_DECL (arg_node), arg_node,
		   "attribute VAR_DECL must be NULL");
    }

/*
 * Attribute check: VAR_NAME
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (VAR_NAME (arg_node), arg_node,
			 "mandatory attribute VAR_NAME is NULL");
    }
  else
    {
      CHKnotExist (VAR_NAME (arg_node), arg_node,
		   "attribute VAR_NAME must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (VAR_INDICES (arg_node) != NULL)
    {
      VAR_INDICES (arg_node) = TRAVdo (VAR_INDICES (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKvardecl
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node VarDecl node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKvardecl (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKvardecl");

/*
 * Son check: VARDECL_DIMS 
 */
  if ((FALSE) || (TRUE))
    {
      if (VARDECL_DIMS (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (VARDECL_DIMS (arg_node)) == N_exprs)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "VARDECL_DIMS hasnt the right type."
					 " It should be: " "N_exprs");
	    }
	}
    }
  else
    {
      CHKnotExist (VARDECL_DIMS (arg_node), arg_node,
		   "attribute VARDECL_DIMS must be NULL");
    }

/*
 * Son check: VARDECL_INIT 
 */
  if ((FALSE) || (TRUE))
    {
      if (VARDECL_INIT (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (VARDECL_INIT (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "VARDECL_INIT hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (VARDECL_INIT (arg_node), arg_node,
		   "attribute VARDECL_INIT must be NULL");
    }

/*
 * Son check: VARDECL_NEXT 
 */
  if ((FALSE) || (TRUE))
    {
      if (VARDECL_NEXT (arg_node) != NULL)
	{
	  if (!
	      ((FALSE) || (NODE_TYPE (VARDECL_NEXT (arg_node)) == N_vardecl)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "VARDECL_NEXT hasnt the right type."
					 " It should be: " "N_vardecl");
	    }
	}
    }
  else
    {
      CHKnotExist (VARDECL_NEXT (arg_node), arg_node,
		   "attribute VARDECL_NEXT must be NULL");
    }

/*
 * Attribute check: VARDECL_NAME
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (VARDECL_NAME (arg_node), arg_node,
			 "mandatory attribute VARDECL_NAME is NULL");
    }
  else
    {
      CHKnotExist (VARDECL_NAME (arg_node), arg_node,
		   "attribute VARDECL_NAME must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (VARDECL_DIMS (arg_node) != NULL)
    {
      VARDECL_DIMS (arg_node) = TRAVdo (VARDECL_DIMS (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (VARDECL_INIT (arg_node) != NULL)
    {
      VARDECL_INIT (arg_node) = TRAVdo (VARDECL_INIT (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (VARDECL_NEXT (arg_node) != NULL)
    {
      VARDECL_NEXT (arg_node) = TRAVdo (VARDECL_NEXT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKvarlet
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node VarLet node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKvarlet (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKvarlet");

/*
 * Son check: VARLET_INDICES 
 */
  if ((FALSE) || (TRUE))
    {
      if (VARLET_INDICES (arg_node) != NULL)
	{
	  if (!
	      ((FALSE) || (NODE_TYPE (VARLET_INDICES (arg_node)) == N_exprs)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "VARLET_INDICES hasnt the right type."
					 " It should be: " "N_exprs");
	    }
	}
    }
  else
    {
      CHKnotExist (VARLET_INDICES (arg_node), arg_node,
		   "attribute VARLET_INDICES must be NULL");
    }

/*
 * Attribute check: VARLET_DECL
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (VARLET_DECL (arg_node), arg_node,
			 "mandatory attribute VARLET_DECL is NULL");
    }
  else
    {
      CHKnotExist (VARLET_DECL (arg_node), arg_node,
		   "attribute VARLET_DECL must be NULL");
    }

/*
 * Attribute check: VARLET_NAME
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (VARLET_NAME (arg_node), arg_node,
			 "mandatory attribute VARLET_NAME is NULL");
    }
  else
    {
      CHKnotExist (VARLET_NAME (arg_node), arg_node,
		   "attribute VARLET_NAME must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (VARLET_INDICES (arg_node) != NULL)
    {
      VARLET_INDICES (arg_node) =
	TRAVdo (VARLET_INDICES (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKwhile
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node While node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKwhile (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKwhile");

/*
 * Son check: WHILE_BLOCK 
 */
  if ((FALSE) || (TRUE))
    {
      if (WHILE_BLOCK (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (WHILE_BLOCK (arg_node)) == N_stmts)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "WHILE_BLOCK hasnt the right type."
					 " It should be: " "N_stmts");
	    }
	}
    }
  else
    {
      CHKnotExist (WHILE_BLOCK (arg_node), arg_node,
		   "attribute WHILE_BLOCK must be NULL");
    }

/*
 * Son check: WHILE_COND 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (WHILE_COND (arg_node), arg_node,
		   "mandatory son WHILE_COND is NULL");
      if (WHILE_COND (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (WHILE_COND (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "WHILE_COND hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (WHILE_COND (arg_node), arg_node,
		   "attribute WHILE_COND must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (WHILE_BLOCK (arg_node) != NULL)
    {
      WHILE_BLOCK (arg_node) = TRAVdo (WHILE_BLOCK (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (WHILE_COND (arg_node) != NULL)
    {
      WHILE_COND (arg_node) = TRAVdo (WHILE_COND (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

typedef enum
{ CHK_binop_op,
  CHK_bool_value,
  CHK_cast_type,
  CHK_error_message,
  CHK_float_value,
  CHK_for_loopvar,
  CHK_funcall_name,
  CHK_fundef_type,
  CHK_globdecl_type,
  CHK_globdef_type,
  CHK_ids_name,
  CHK_monop_op,
  CHK_num_value,
  CHK_param_name,
  CHK_symboltable_parent,
  CHK_symboltableentry_name,
  CHK_var_name,
  CHK_vardecl_name,
  CHK_varlet_name,
} attr_list;
