
/**
 * @file node_basic.c
 *
 * Functions to allocate node structures
 * 
 * THIS FILE HAS BEEN GENERATED USING 
 * $Id: node_basic.c.xsl 14593 2006-01-31 17:09:55Z cg $.
 * DO NOT EDIT THIS FILE AS MIGHT BE CHANGED IN A LATER VERSION.
 *
 * ALL CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN!
 *
 */

#include "node_basic.h"
#include "tree_basic.h"
#include "memory.h"
#include "dbug.h"
#include "globals.h"
#include "ctinfo.h"

static node *
MakeEmptyNode ()
{
  node *result;

  DBUG_ENTER ("MakeEmptyNode");

  result = (node *) MEMmalloc (sizeof (node));

  NODE_LINE (result) = global.line;
  NODE_COL (result) = global.col;

  DBUG_RETURN (result);
}



/*****************************************************************************
 * N_Program :
 *****************************************************************************/

node *
TBmakeProgram (node * Decls)
{
  node *this;
  DBUG_ENTER ("TBmakeProgram");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_program;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_program = MEMmalloc (sizeof (struct SONS_N_PROGRAM));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_program = MEMmalloc (sizeof (struct ATTRIBS_N_PROGRAM));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_program;
  DBUG_PRINT ("MAKE", ("assigning son Decls initial value: %s ", Decls));
  PROGRAM_DECLS (this) = Decls;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((PROGRAM_DECLS (this) != NULL)
      && (NODE_TYPE (PROGRAM_DECLS (this)) != N_decls))
    {
      CTIwarn ("Field Decls of node N_Program has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_SymbolTable :
 *****************************************************************************/

node *
TBmakeSymboltable (node * Entry)
{
  node *this;
  DBUG_ENTER ("TBmakeSymboltable");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_symboltable;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_symboltable = MEMmalloc (sizeof (struct SONS_N_SYMBOLTABLE));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_symboltable =
    MEMmalloc (sizeof (struct ATTRIBS_N_SYMBOLTABLE));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_symboltable;
  DBUG_PRINT ("MAKE", ("assigning son Entry initial value: %s ", Entry));
  SYMBOLTABLE_ENTRY (this) = Entry;
  SYMBOLTABLE_PARENT (this) = NULL;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((SYMBOLTABLE_ENTRY (this) != NULL)
      && (NODE_TYPE (SYMBOLTABLE_ENTRY (this)) != N_symboltableentry))
    {
      CTIwarn
	("Field Entry of node N_SymbolTable has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_SymbolTableEntry :
 *****************************************************************************/

node *
TBmakeSymboltableentry (char *Name, type Type, int Depth, node * Node,
			node * Next, node * Table)
{
  node *this;
  DBUG_ENTER ("TBmakeSymboltableentry");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_symboltableentry;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_symboltableentry =
    MEMmalloc (sizeof (struct SONS_N_SYMBOLTABLEENTRY));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_symboltableentry =
    MEMmalloc (sizeof (struct ATTRIBS_N_SYMBOLTABLEENTRY));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_symboltableentry;
  DBUG_PRINT ("MAKE", ("assigning son Next initial value: %s ", Next));
  SYMBOLTABLEENTRY_NEXT (this) = Next;
  DBUG_PRINT ("MAKE", ("assigning son Table initial value: %s ", Table));
  SYMBOLTABLEENTRY_TABLE (this) = Table;
  SYMBOLTABLEENTRY_NAME (this) = Name;
  SYMBOLTABLEENTRY_TYPE (this) = Type;
  SYMBOLTABLEENTRY_DEPTH (this) = Depth;
  SYMBOLTABLEENTRY_NODE (this) = Node;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((SYMBOLTABLEENTRY_NEXT (this) != NULL)
      && (NODE_TYPE (SYMBOLTABLEENTRY_NEXT (this)) != N_symboltableentry))
    {
      CTIwarn
	("Field Next of node N_SymbolTableEntry has non-allowed target node.");
    }
  if ((SYMBOLTABLEENTRY_TABLE (this) != NULL)
      && (NODE_TYPE (SYMBOLTABLEENTRY_TABLE (this)) != N_symboltable))
    {
      CTIwarn
	("Field Table of node N_SymbolTableEntry has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Decls :
 *****************************************************************************/

node *
TBmakeDecls (node * Decl, node * Next)
{
  node *this;
  DBUG_ENTER ("TBmakeDecls");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_decls;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_decls = MEMmalloc (sizeof (struct SONS_N_DECLS));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_decls = MEMmalloc (sizeof (struct ATTRIBS_N_DECLS));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_decls;
  DBUG_PRINT ("MAKE", ("assigning son Decl initial value: %s ", Decl));
  DECLS_DECL (this) = Decl;
  DBUG_PRINT ("MAKE", ("assigning son Next initial value: %s ", Next));
  DECLS_NEXT (this) = Next;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((DECLS_DECL (this) != NULL)
      && (NODE_TYPE (DECLS_DECL (this)) != N_fundef)
      && (NODE_TYPE (DECLS_DECL (this)) != N_globdecl)
      && (NODE_TYPE (DECLS_DECL (this)) != N_globdef))
    {
      CTIwarn ("Field Decl of node N_Decls has non-allowed target node.");
    }
  if ((DECLS_NEXT (this) != NULL)
      && (NODE_TYPE (DECLS_NEXT (this)) != N_decls))
    {
      CTIwarn ("Field Next of node N_Decls has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Exprs :
 *****************************************************************************/

node *
TBmakeExprs (node * Expr, node * Next)
{
  node *this;
  DBUG_ENTER ("TBmakeExprs");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_exprs;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_exprs = MEMmalloc (sizeof (struct SONS_N_EXPRS));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_exprs = MEMmalloc (sizeof (struct ATTRIBS_N_EXPRS));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_exprs;
  DBUG_PRINT ("MAKE", ("assigning son Expr initial value: %s ", Expr));
  EXPRS_EXPR (this) = Expr;
  DBUG_PRINT ("MAKE", ("assigning son Next initial value: %s ", Next));
  EXPRS_NEXT (this) = Next;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((EXPRS_EXPR (this) != NULL)
      && (NODE_TYPE (EXPRS_EXPR (this)) != N_binop)
      && (NODE_TYPE (EXPRS_EXPR (this)) != N_monop)
      && (NODE_TYPE (EXPRS_EXPR (this)) != N_funcall)
      && (NODE_TYPE (EXPRS_EXPR (this)) != N_cast)
      && (NODE_TYPE (EXPRS_EXPR (this)) != N_var)
      && (NODE_TYPE (EXPRS_EXPR (this)) != N_num)
      && (NODE_TYPE (EXPRS_EXPR (this)) != N_float)
      && (NODE_TYPE (EXPRS_EXPR (this)) != N_bool)
      && (NODE_TYPE (EXPRS_EXPR (this)) != N_arrexpr))
    {
      CTIwarn ("Field Expr of node N_Exprs has non-allowed target node.");
    }
  if ((EXPRS_NEXT (this) != NULL)
      && (NODE_TYPE (EXPRS_NEXT (this)) != N_exprs))
    {
      CTIwarn ("Field Next of node N_Exprs has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_ArrExpr :
 *****************************************************************************/

node *
TBmakeArrexpr (node * Exprs)
{
  node *this;
  DBUG_ENTER ("TBmakeArrexpr");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_arrexpr;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_arrexpr = MEMmalloc (sizeof (struct SONS_N_ARREXPR));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_arrexpr = MEMmalloc (sizeof (struct ATTRIBS_N_ARREXPR));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_arrexpr;
  DBUG_PRINT ("MAKE", ("assigning son Exprs initial value: %s ", Exprs));
  ARREXPR_EXPRS (this) = Exprs;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((ARREXPR_EXPRS (this) != NULL)
      && (NODE_TYPE (ARREXPR_EXPRS (this)) != N_exprs))
    {
      CTIwarn ("Field Exprs of node N_ArrExpr has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Ids :
 *****************************************************************************/

node *
TBmakeIds (char *Name, node * Next)
{
  node *this;
  DBUG_ENTER ("TBmakeIds");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_ids;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_ids = MEMmalloc (sizeof (struct SONS_N_IDS));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_ids = MEMmalloc (sizeof (struct ATTRIBS_N_IDS));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_ids;
  DBUG_PRINT ("MAKE", ("assigning son Next initial value: %s ", Next));
  IDS_NEXT (this) = Next;
  IDS_NAME (this) = Name;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((IDS_NEXT (this) != NULL) && (NODE_TYPE (IDS_NEXT (this)) != N_ids))
    {
      CTIwarn ("Field Next of node N_Ids has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_ExprStmt :
 *****************************************************************************/

node *
TBmakeExprstmt (node * Expr)
{
  node *this;
  DBUG_ENTER ("TBmakeExprstmt");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_exprstmt;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_exprstmt = MEMmalloc (sizeof (struct SONS_N_EXPRSTMT));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_exprstmt = MEMmalloc (sizeof (struct ATTRIBS_N_EXPRSTMT));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_exprstmt;
  DBUG_PRINT ("MAKE", ("assigning son Expr initial value: %s ", Expr));
  EXPRSTMT_EXPR (this) = Expr;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((EXPRSTMT_EXPR (this) != NULL)
      && (NODE_TYPE (EXPRSTMT_EXPR (this)) != N_binop)
      && (NODE_TYPE (EXPRSTMT_EXPR (this)) != N_monop)
      && (NODE_TYPE (EXPRSTMT_EXPR (this)) != N_funcall)
      && (NODE_TYPE (EXPRSTMT_EXPR (this)) != N_cast)
      && (NODE_TYPE (EXPRSTMT_EXPR (this)) != N_var)
      && (NODE_TYPE (EXPRSTMT_EXPR (this)) != N_num)
      && (NODE_TYPE (EXPRSTMT_EXPR (this)) != N_float)
      && (NODE_TYPE (EXPRSTMT_EXPR (this)) != N_bool)
      && (NODE_TYPE (EXPRSTMT_EXPR (this)) != N_arrexpr))
    {
      CTIwarn ("Field Expr of node N_ExprStmt has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Return :
 *****************************************************************************/

node *
TBmakeReturn (node * Expr)
{
  node *this;
  DBUG_ENTER ("TBmakeReturn");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_return;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_return = MEMmalloc (sizeof (struct SONS_N_RETURN));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_return = MEMmalloc (sizeof (struct ATTRIBS_N_RETURN));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_return;
  DBUG_PRINT ("MAKE", ("assigning son Expr initial value: %s ", Expr));
  RETURN_EXPR (this) = Expr;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((RETURN_EXPR (this) != NULL)
      && (NODE_TYPE (RETURN_EXPR (this)) != N_binop)
      && (NODE_TYPE (RETURN_EXPR (this)) != N_monop)
      && (NODE_TYPE (RETURN_EXPR (this)) != N_funcall)
      && (NODE_TYPE (RETURN_EXPR (this)) != N_cast)
      && (NODE_TYPE (RETURN_EXPR (this)) != N_var)
      && (NODE_TYPE (RETURN_EXPR (this)) != N_num)
      && (NODE_TYPE (RETURN_EXPR (this)) != N_float)
      && (NODE_TYPE (RETURN_EXPR (this)) != N_bool)
      && (NODE_TYPE (RETURN_EXPR (this)) != N_arrexpr))
    {
      CTIwarn ("Field Expr of node N_Return has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_FunCall :
 *****************************************************************************/

node *
TBmakeFuncall (char *Name, node * Decl, node * Args)
{
  node *this;
  DBUG_ENTER ("TBmakeFuncall");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_funcall;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_funcall = MEMmalloc (sizeof (struct SONS_N_FUNCALL));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_funcall = MEMmalloc (sizeof (struct ATTRIBS_N_FUNCALL));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_funcall;
  DBUG_PRINT ("MAKE", ("assigning son Args initial value: %s ", Args));
  FUNCALL_ARGS (this) = Args;
  FUNCALL_NAME (this) = Name;
  FUNCALL_DECL (this) = Decl;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((FUNCALL_ARGS (this) != NULL)
      && (NODE_TYPE (FUNCALL_ARGS (this)) != N_exprs))
    {
      CTIwarn ("Field Args of node N_FunCall has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Cast :
 *****************************************************************************/

node *
TBmakeCast (type Type, node * Expr)
{
  node *this;
  DBUG_ENTER ("TBmakeCast");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_cast;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_cast = MEMmalloc (sizeof (struct SONS_N_CAST));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_cast = MEMmalloc (sizeof (struct ATTRIBS_N_CAST));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_cast;
  DBUG_PRINT ("MAKE", ("assigning son Expr initial value: %s ", Expr));
  CAST_EXPR (this) = Expr;
  CAST_TYPE (this) = Type;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((CAST_EXPR (this) != NULL) && (NODE_TYPE (CAST_EXPR (this)) != N_binop)
      && (NODE_TYPE (CAST_EXPR (this)) != N_monop)
      && (NODE_TYPE (CAST_EXPR (this)) != N_funcall)
      && (NODE_TYPE (CAST_EXPR (this)) != N_cast)
      && (NODE_TYPE (CAST_EXPR (this)) != N_var)
      && (NODE_TYPE (CAST_EXPR (this)) != N_num)
      && (NODE_TYPE (CAST_EXPR (this)) != N_float)
      && (NODE_TYPE (CAST_EXPR (this)) != N_bool)
      && (NODE_TYPE (CAST_EXPR (this)) != N_arrexpr))
    {
      CTIwarn ("Field Expr of node N_Cast has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_FunDefs :
 *****************************************************************************/

node *
TBmakeFundefs (node * Fundef, node * Next)
{
  node *this;
  DBUG_ENTER ("TBmakeFundefs");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_fundefs;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_fundefs = MEMmalloc (sizeof (struct SONS_N_FUNDEFS));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_fundefs = MEMmalloc (sizeof (struct ATTRIBS_N_FUNDEFS));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_fundefs;
  DBUG_PRINT ("MAKE", ("assigning son Fundef initial value: %s ", Fundef));
  FUNDEFS_FUNDEF (this) = Fundef;
  DBUG_PRINT ("MAKE", ("assigning son Next initial value: %s ", Next));
  FUNDEFS_NEXT (this) = Next;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((FUNDEFS_FUNDEF (this) != NULL)
      && (NODE_TYPE (FUNDEFS_FUNDEF (this)) != N_fundef))
    {
      CTIwarn ("Field Fundef of node N_FunDefs has non-allowed target node.");
    }
  if ((FUNDEFS_NEXT (this) != NULL)
      && (NODE_TYPE (FUNDEFS_NEXT (this)) != N_fundefs))
    {
      CTIwarn ("Field Next of node N_FunDefs has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_FunDef :
 *****************************************************************************/

node *
TBmakeFundef (type Type, char *Name, node * FunBody, node * Params)
{
  node *this;
  DBUG_ENTER ("TBmakeFundef");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_fundef;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_fundef = MEMmalloc (sizeof (struct SONS_N_FUNDEF));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_fundef = MEMmalloc (sizeof (struct ATTRIBS_N_FUNDEF));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_fundef;
  DBUG_PRINT ("MAKE", ("assigning son FunBody initial value: %s ", FunBody));
  FUNDEF_FUNBODY (this) = FunBody;
  DBUG_PRINT ("MAKE", ("assigning son Params initial value: %s ", Params));
  FUNDEF_PARAMS (this) = Params;
  FUNDEF_TYPE (this) = Type;
  FUNDEF_NAME (this) = Name;
  FUNDEF_ISEXPORT (this) = FALSE;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((FUNDEF_FUNBODY (this) != NULL)
      && (NODE_TYPE (FUNDEF_FUNBODY (this)) != N_funbody))
    {
      CTIwarn ("Field FunBody of node N_FunDef has non-allowed target node.");
    }
  if ((FUNDEF_PARAMS (this) != NULL)
      && (NODE_TYPE (FUNDEF_PARAMS (this)) != N_param))
    {
      CTIwarn ("Field Params of node N_FunDef has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_FunBody :
 *****************************************************************************/

node *
TBmakeFunbody (node * Vardecls, node * LocalFundefs, node * Stmts)
{
  node *this;
  DBUG_ENTER ("TBmakeFunbody");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_funbody;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_funbody = MEMmalloc (sizeof (struct SONS_N_FUNBODY));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_funbody = MEMmalloc (sizeof (struct ATTRIBS_N_FUNBODY));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_funbody;
  DBUG_PRINT ("MAKE",
	      ("assigning son Vardecls initial value: %s ", Vardecls));
  FUNBODY_VARDECLS (this) = Vardecls;
  DBUG_PRINT ("MAKE",
	      ("assigning son LocalFundefs initial value: %s ",
	       LocalFundefs));
  FUNBODY_LOCALFUNDEFS (this) = LocalFundefs;
  DBUG_PRINT ("MAKE", ("assigning son Stmts initial value: %s ", Stmts));
  FUNBODY_STMTS (this) = Stmts;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((FUNBODY_VARDECLS (this) != NULL)
      && (NODE_TYPE (FUNBODY_VARDECLS (this)) != N_vardecl))
    {
      CTIwarn
	("Field Vardecls of node N_FunBody has non-allowed target node.");
    }
  if ((FUNBODY_LOCALFUNDEFS (this) != NULL)
      && (NODE_TYPE (FUNBODY_LOCALFUNDEFS (this)) != N_fundefs))
    {
      CTIwarn
	("Field LocalFundefs of node N_FunBody has non-allowed target node.");
    }
  if ((FUNBODY_STMTS (this) != NULL)
      && (NODE_TYPE (FUNBODY_STMTS (this)) != N_stmts))
    {
      CTIwarn ("Field Stmts of node N_FunBody has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_IfElse :
 *****************************************************************************/

node *
TBmakeIfelse (node * Cond, node * Then, node * Else)
{
  node *this;
  DBUG_ENTER ("TBmakeIfelse");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_ifelse;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_ifelse = MEMmalloc (sizeof (struct SONS_N_IFELSE));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_ifelse = MEMmalloc (sizeof (struct ATTRIBS_N_IFELSE));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_ifelse;
  DBUG_PRINT ("MAKE", ("assigning son Cond initial value: %s ", Cond));
  IFELSE_COND (this) = Cond;
  DBUG_PRINT ("MAKE", ("assigning son Then initial value: %s ", Then));
  IFELSE_THEN (this) = Then;
  DBUG_PRINT ("MAKE", ("assigning son Else initial value: %s ", Else));
  IFELSE_ELSE (this) = Else;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((IFELSE_COND (this) != NULL)
      && (NODE_TYPE (IFELSE_COND (this)) != N_binop)
      && (NODE_TYPE (IFELSE_COND (this)) != N_monop)
      && (NODE_TYPE (IFELSE_COND (this)) != N_funcall)
      && (NODE_TYPE (IFELSE_COND (this)) != N_cast)
      && (NODE_TYPE (IFELSE_COND (this)) != N_var)
      && (NODE_TYPE (IFELSE_COND (this)) != N_num)
      && (NODE_TYPE (IFELSE_COND (this)) != N_float)
      && (NODE_TYPE (IFELSE_COND (this)) != N_bool)
      && (NODE_TYPE (IFELSE_COND (this)) != N_arrexpr))
    {
      CTIwarn ("Field Cond of node N_IfElse has non-allowed target node.");
    }
  if ((IFELSE_THEN (this) != NULL)
      && (NODE_TYPE (IFELSE_THEN (this)) != N_stmts))
    {
      CTIwarn ("Field Then of node N_IfElse has non-allowed target node.");
    }
  if ((IFELSE_ELSE (this) != NULL)
      && (NODE_TYPE (IFELSE_ELSE (this)) != N_stmts))
    {
      CTIwarn ("Field Else of node N_IfElse has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_While :
 *****************************************************************************/

node *
TBmakeWhile (node * Cond, node * Block)
{
  node *this;
  DBUG_ENTER ("TBmakeWhile");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_while;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_while = MEMmalloc (sizeof (struct SONS_N_WHILE));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_while = MEMmalloc (sizeof (struct ATTRIBS_N_WHILE));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_while;
  DBUG_PRINT ("MAKE", ("assigning son Cond initial value: %s ", Cond));
  WHILE_COND (this) = Cond;
  DBUG_PRINT ("MAKE", ("assigning son Block initial value: %s ", Block));
  WHILE_BLOCK (this) = Block;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((WHILE_COND (this) != NULL)
      && (NODE_TYPE (WHILE_COND (this)) != N_binop)
      && (NODE_TYPE (WHILE_COND (this)) != N_monop)
      && (NODE_TYPE (WHILE_COND (this)) != N_funcall)
      && (NODE_TYPE (WHILE_COND (this)) != N_cast)
      && (NODE_TYPE (WHILE_COND (this)) != N_var)
      && (NODE_TYPE (WHILE_COND (this)) != N_num)
      && (NODE_TYPE (WHILE_COND (this)) != N_float)
      && (NODE_TYPE (WHILE_COND (this)) != N_bool)
      && (NODE_TYPE (WHILE_COND (this)) != N_arrexpr))
    {
      CTIwarn ("Field Cond of node N_While has non-allowed target node.");
    }
  if ((WHILE_BLOCK (this) != NULL)
      && (NODE_TYPE (WHILE_BLOCK (this)) != N_stmts))
    {
      CTIwarn ("Field Block of node N_While has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_DoWhile :
 *****************************************************************************/

node *
TBmakeDowhile (node * Cond, node * Block)
{
  node *this;
  DBUG_ENTER ("TBmakeDowhile");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_dowhile;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_dowhile = MEMmalloc (sizeof (struct SONS_N_DOWHILE));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_dowhile = MEMmalloc (sizeof (struct ATTRIBS_N_DOWHILE));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_dowhile;
  DBUG_PRINT ("MAKE", ("assigning son Cond initial value: %s ", Cond));
  DOWHILE_COND (this) = Cond;
  DBUG_PRINT ("MAKE", ("assigning son Block initial value: %s ", Block));
  DOWHILE_BLOCK (this) = Block;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((DOWHILE_COND (this) != NULL)
      && (NODE_TYPE (DOWHILE_COND (this)) != N_binop)
      && (NODE_TYPE (DOWHILE_COND (this)) != N_monop)
      && (NODE_TYPE (DOWHILE_COND (this)) != N_funcall)
      && (NODE_TYPE (DOWHILE_COND (this)) != N_cast)
      && (NODE_TYPE (DOWHILE_COND (this)) != N_var)
      && (NODE_TYPE (DOWHILE_COND (this)) != N_num)
      && (NODE_TYPE (DOWHILE_COND (this)) != N_float)
      && (NODE_TYPE (DOWHILE_COND (this)) != N_bool)
      && (NODE_TYPE (DOWHILE_COND (this)) != N_arrexpr))
    {
      CTIwarn ("Field Cond of node N_DoWhile has non-allowed target node.");
    }
  if ((DOWHILE_BLOCK (this) != NULL)
      && (NODE_TYPE (DOWHILE_BLOCK (this)) != N_stmts))
    {
      CTIwarn ("Field Block of node N_DoWhile has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_For :
 *****************************************************************************/

node *
TBmakeFor (char *LoopVar, node * Start, node * Stop, node * Step,
	   node * Block)
{
  node *this;
  DBUG_ENTER ("TBmakeFor");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_for;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_for = MEMmalloc (sizeof (struct SONS_N_FOR));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_for = MEMmalloc (sizeof (struct ATTRIBS_N_FOR));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_for;
  DBUG_PRINT ("MAKE", ("assigning son Start initial value: %s ", Start));
  FOR_START (this) = Start;
  DBUG_PRINT ("MAKE", ("assigning son Stop initial value: %s ", Stop));
  FOR_STOP (this) = Stop;
  DBUG_PRINT ("MAKE", ("assigning son Step initial value: %s ", Step));
  FOR_STEP (this) = Step;
  DBUG_PRINT ("MAKE", ("assigning son Block initial value: %s ", Block));
  FOR_BLOCK (this) = Block;
  FOR_LOOPVAR (this) = LoopVar;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((FOR_START (this) != NULL) && (NODE_TYPE (FOR_START (this)) != N_binop)
      && (NODE_TYPE (FOR_START (this)) != N_monop)
      && (NODE_TYPE (FOR_START (this)) != N_funcall)
      && (NODE_TYPE (FOR_START (this)) != N_cast)
      && (NODE_TYPE (FOR_START (this)) != N_var)
      && (NODE_TYPE (FOR_START (this)) != N_num)
      && (NODE_TYPE (FOR_START (this)) != N_float)
      && (NODE_TYPE (FOR_START (this)) != N_bool)
      && (NODE_TYPE (FOR_START (this)) != N_arrexpr))
    {
      CTIwarn ("Field Start of node N_For has non-allowed target node.");
    }
  if ((FOR_STOP (this) != NULL) && (NODE_TYPE (FOR_STOP (this)) != N_binop)
      && (NODE_TYPE (FOR_STOP (this)) != N_monop)
      && (NODE_TYPE (FOR_STOP (this)) != N_funcall)
      && (NODE_TYPE (FOR_STOP (this)) != N_cast)
      && (NODE_TYPE (FOR_STOP (this)) != N_var)
      && (NODE_TYPE (FOR_STOP (this)) != N_num)
      && (NODE_TYPE (FOR_STOP (this)) != N_float)
      && (NODE_TYPE (FOR_STOP (this)) != N_bool)
      && (NODE_TYPE (FOR_STOP (this)) != N_arrexpr))
    {
      CTIwarn ("Field Stop of node N_For has non-allowed target node.");
    }
  if ((FOR_STEP (this) != NULL) && (NODE_TYPE (FOR_STEP (this)) != N_binop)
      && (NODE_TYPE (FOR_STEP (this)) != N_monop)
      && (NODE_TYPE (FOR_STEP (this)) != N_funcall)
      && (NODE_TYPE (FOR_STEP (this)) != N_cast)
      && (NODE_TYPE (FOR_STEP (this)) != N_var)
      && (NODE_TYPE (FOR_STEP (this)) != N_num)
      && (NODE_TYPE (FOR_STEP (this)) != N_float)
      && (NODE_TYPE (FOR_STEP (this)) != N_bool)
      && (NODE_TYPE (FOR_STEP (this)) != N_arrexpr))
    {
      CTIwarn ("Field Step of node N_For has non-allowed target node.");
    }
  if ((FOR_BLOCK (this) != NULL) && (NODE_TYPE (FOR_BLOCK (this)) != N_stmts))
    {
      CTIwarn ("Field Block of node N_For has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_GlobDecl :
 *****************************************************************************/

node *
TBmakeGlobdecl (type Type, char *Name, node * Dims)
{
  node *this;
  DBUG_ENTER ("TBmakeGlobdecl");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_globdecl;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_globdecl = MEMmalloc (sizeof (struct SONS_N_GLOBDECL));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_globdecl = MEMmalloc (sizeof (struct ATTRIBS_N_GLOBDECL));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_globdecl;
  DBUG_PRINT ("MAKE", ("assigning son Dims initial value: %s ", Dims));
  GLOBDECL_DIMS (this) = Dims;
  GLOBDECL_TYPE (this) = Type;
  GLOBDECL_NAME (this) = Name;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((GLOBDECL_DIMS (this) != NULL)
      && (NODE_TYPE (GLOBDECL_DIMS (this)) != N_ids))
    {
      CTIwarn ("Field Dims of node N_GlobDecl has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_GlobDef :
 *****************************************************************************/

node *
TBmakeGlobdef (type Type, char *Name, node * Dims, node * Init)
{
  node *this;
  DBUG_ENTER ("TBmakeGlobdef");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_globdef;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_globdef = MEMmalloc (sizeof (struct SONS_N_GLOBDEF));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_globdef = MEMmalloc (sizeof (struct ATTRIBS_N_GLOBDEF));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_globdef;
  DBUG_PRINT ("MAKE", ("assigning son Dims initial value: %s ", Dims));
  GLOBDEF_DIMS (this) = Dims;
  DBUG_PRINT ("MAKE", ("assigning son Init initial value: %s ", Init));
  GLOBDEF_INIT (this) = Init;
  GLOBDEF_TYPE (this) = Type;
  GLOBDEF_NAME (this) = Name;
  GLOBDEF_ISEXPORT (this) = FALSE;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((GLOBDEF_DIMS (this) != NULL)
      && (NODE_TYPE (GLOBDEF_DIMS (this)) != N_exprs))
    {
      CTIwarn ("Field Dims of node N_GlobDef has non-allowed target node.");
    }
  if ((GLOBDEF_INIT (this) != NULL)
      && (NODE_TYPE (GLOBDEF_INIT (this)) != N_binop)
      && (NODE_TYPE (GLOBDEF_INIT (this)) != N_monop)
      && (NODE_TYPE (GLOBDEF_INIT (this)) != N_funcall)
      && (NODE_TYPE (GLOBDEF_INIT (this)) != N_cast)
      && (NODE_TYPE (GLOBDEF_INIT (this)) != N_var)
      && (NODE_TYPE (GLOBDEF_INIT (this)) != N_num)
      && (NODE_TYPE (GLOBDEF_INIT (this)) != N_float)
      && (NODE_TYPE (GLOBDEF_INIT (this)) != N_bool)
      && (NODE_TYPE (GLOBDEF_INIT (this)) != N_arrexpr))
    {
      CTIwarn ("Field Init of node N_GlobDef has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Param :
 *****************************************************************************/

node *
TBmakeParam (char *Name, type Type, node * Dims, node * Next)
{
  node *this;
  DBUG_ENTER ("TBmakeParam");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_param;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_param = MEMmalloc (sizeof (struct SONS_N_PARAM));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_param = MEMmalloc (sizeof (struct ATTRIBS_N_PARAM));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_param;
  DBUG_PRINT ("MAKE", ("assigning son Dims initial value: %s ", Dims));
  PARAM_DIMS (this) = Dims;
  DBUG_PRINT ("MAKE", ("assigning son Next initial value: %s ", Next));
  PARAM_NEXT (this) = Next;
  PARAM_NAME (this) = Name;
  PARAM_TYPE (this) = Type;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((PARAM_DIMS (this) != NULL) && (NODE_TYPE (PARAM_DIMS (this)) != N_ids))
    {
      CTIwarn ("Field Dims of node N_Param has non-allowed target node.");
    }
  if ((PARAM_NEXT (this) != NULL)
      && (NODE_TYPE (PARAM_NEXT (this)) != N_param))
    {
      CTIwarn ("Field Next of node N_Param has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_VarDecl :
 *****************************************************************************/

node *
TBmakeVardecl (char *Name, type Type, node * Dims, node * Init, node * Next)
{
  node *this;
  DBUG_ENTER ("TBmakeVardecl");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_vardecl;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_vardecl = MEMmalloc (sizeof (struct SONS_N_VARDECL));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_vardecl = MEMmalloc (sizeof (struct ATTRIBS_N_VARDECL));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_vardecl;
  DBUG_PRINT ("MAKE", ("assigning son Dims initial value: %s ", Dims));
  VARDECL_DIMS (this) = Dims;
  DBUG_PRINT ("MAKE", ("assigning son Init initial value: %s ", Init));
  VARDECL_INIT (this) = Init;
  DBUG_PRINT ("MAKE", ("assigning son Next initial value: %s ", Next));
  VARDECL_NEXT (this) = Next;
  VARDECL_NAME (this) = Name;
  VARDECL_TYPE (this) = Type;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((VARDECL_DIMS (this) != NULL)
      && (NODE_TYPE (VARDECL_DIMS (this)) != N_exprs))
    {
      CTIwarn ("Field Dims of node N_VarDecl has non-allowed target node.");
    }
  if ((VARDECL_INIT (this) != NULL)
      && (NODE_TYPE (VARDECL_INIT (this)) != N_binop)
      && (NODE_TYPE (VARDECL_INIT (this)) != N_monop)
      && (NODE_TYPE (VARDECL_INIT (this)) != N_funcall)
      && (NODE_TYPE (VARDECL_INIT (this)) != N_cast)
      && (NODE_TYPE (VARDECL_INIT (this)) != N_var)
      && (NODE_TYPE (VARDECL_INIT (this)) != N_num)
      && (NODE_TYPE (VARDECL_INIT (this)) != N_float)
      && (NODE_TYPE (VARDECL_INIT (this)) != N_bool)
      && (NODE_TYPE (VARDECL_INIT (this)) != N_arrexpr))
    {
      CTIwarn ("Field Init of node N_VarDecl has non-allowed target node.");
    }
  if ((VARDECL_NEXT (this) != NULL)
      && (NODE_TYPE (VARDECL_NEXT (this)) != N_vardecl))
    {
      CTIwarn ("Field Next of node N_VarDecl has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Stmts :
 *****************************************************************************/

node *
TBmakeStmts (node * Stmt, node * Next)
{
  node *this;
  DBUG_ENTER ("TBmakeStmts");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_stmts;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_stmts = MEMmalloc (sizeof (struct SONS_N_STMTS));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_stmts = MEMmalloc (sizeof (struct ATTRIBS_N_STMTS));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_stmts;
  DBUG_PRINT ("MAKE", ("assigning son Stmt initial value: %s ", Stmt));
  STMTS_STMT (this) = Stmt;
  DBUG_PRINT ("MAKE", ("assigning son Next initial value: %s ", Next));
  STMTS_NEXT (this) = Next;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((STMTS_STMT (this) != NULL)
      && (NODE_TYPE (STMTS_STMT (this)) != N_assign)
      && (NODE_TYPE (STMTS_STMT (this)) != N_exprstmt)
      && (NODE_TYPE (STMTS_STMT (this)) != N_ifelse)
      && (NODE_TYPE (STMTS_STMT (this)) != N_while)
      && (NODE_TYPE (STMTS_STMT (this)) != N_dowhile)
      && (NODE_TYPE (STMTS_STMT (this)) != N_for)
      && (NODE_TYPE (STMTS_STMT (this)) != N_return))
    {
      CTIwarn ("Field Stmt of node N_Stmts has non-allowed target node.");
    }
  if ((STMTS_NEXT (this) != NULL)
      && (NODE_TYPE (STMTS_NEXT (this)) != N_stmts))
    {
      CTIwarn ("Field Next of node N_Stmts has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Assign :
 *****************************************************************************/

node *
TBmakeAssign (node * Let, node * Expr)
{
  node *this;
  DBUG_ENTER ("TBmakeAssign");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_assign;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_assign = MEMmalloc (sizeof (struct SONS_N_ASSIGN));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_assign = MEMmalloc (sizeof (struct ATTRIBS_N_ASSIGN));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_assign;
  DBUG_PRINT ("MAKE", ("assigning son Let initial value: %s ", Let));
  ASSIGN_LET (this) = Let;
  DBUG_PRINT ("MAKE", ("assigning son Expr initial value: %s ", Expr));
  ASSIGN_EXPR (this) = Expr;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((ASSIGN_LET (this) != NULL)
      && (NODE_TYPE (ASSIGN_LET (this)) != N_varlet))
    {
      CTIwarn ("Field Let of node N_Assign has non-allowed target node.");
    }
  if ((ASSIGN_EXPR (this) != NULL)
      && (NODE_TYPE (ASSIGN_EXPR (this)) != N_binop)
      && (NODE_TYPE (ASSIGN_EXPR (this)) != N_monop)
      && (NODE_TYPE (ASSIGN_EXPR (this)) != N_funcall)
      && (NODE_TYPE (ASSIGN_EXPR (this)) != N_cast)
      && (NODE_TYPE (ASSIGN_EXPR (this)) != N_var)
      && (NODE_TYPE (ASSIGN_EXPR (this)) != N_num)
      && (NODE_TYPE (ASSIGN_EXPR (this)) != N_float)
      && (NODE_TYPE (ASSIGN_EXPR (this)) != N_bool)
      && (NODE_TYPE (ASSIGN_EXPR (this)) != N_arrexpr))
    {
      CTIwarn ("Field Expr of node N_Assign has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_BinOp :
 *****************************************************************************/

node *
TBmakeBinop (binop Op, node * Left, node * Right)
{
  node *this;
  DBUG_ENTER ("TBmakeBinop");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_binop;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_binop = MEMmalloc (sizeof (struct SONS_N_BINOP));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_binop = MEMmalloc (sizeof (struct ATTRIBS_N_BINOP));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_binop;
  DBUG_PRINT ("MAKE", ("assigning son Left initial value: %s ", Left));
  BINOP_LEFT (this) = Left;
  DBUG_PRINT ("MAKE", ("assigning son Right initial value: %s ", Right));
  BINOP_RIGHT (this) = Right;
  BINOP_OP (this) = Op;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((BINOP_LEFT (this) != NULL)
      && (NODE_TYPE (BINOP_LEFT (this)) != N_binop)
      && (NODE_TYPE (BINOP_LEFT (this)) != N_monop)
      && (NODE_TYPE (BINOP_LEFT (this)) != N_funcall)
      && (NODE_TYPE (BINOP_LEFT (this)) != N_cast)
      && (NODE_TYPE (BINOP_LEFT (this)) != N_var)
      && (NODE_TYPE (BINOP_LEFT (this)) != N_num)
      && (NODE_TYPE (BINOP_LEFT (this)) != N_float)
      && (NODE_TYPE (BINOP_LEFT (this)) != N_bool)
      && (NODE_TYPE (BINOP_LEFT (this)) != N_arrexpr))
    {
      CTIwarn ("Field Left of node N_BinOp has non-allowed target node.");
    }
  if ((BINOP_RIGHT (this) != NULL)
      && (NODE_TYPE (BINOP_RIGHT (this)) != N_binop)
      && (NODE_TYPE (BINOP_RIGHT (this)) != N_monop)
      && (NODE_TYPE (BINOP_RIGHT (this)) != N_funcall)
      && (NODE_TYPE (BINOP_RIGHT (this)) != N_cast)
      && (NODE_TYPE (BINOP_RIGHT (this)) != N_var)
      && (NODE_TYPE (BINOP_RIGHT (this)) != N_num)
      && (NODE_TYPE (BINOP_RIGHT (this)) != N_float)
      && (NODE_TYPE (BINOP_RIGHT (this)) != N_bool)
      && (NODE_TYPE (BINOP_RIGHT (this)) != N_arrexpr))
    {
      CTIwarn ("Field Right of node N_BinOp has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_MonOp :
 *****************************************************************************/

node *
TBmakeMonop (monop Op, node * Operand)
{
  node *this;
  DBUG_ENTER ("TBmakeMonop");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_monop;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_monop = MEMmalloc (sizeof (struct SONS_N_MONOP));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_monop = MEMmalloc (sizeof (struct ATTRIBS_N_MONOP));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_monop;
  DBUG_PRINT ("MAKE", ("assigning son Operand initial value: %s ", Operand));
  MONOP_OPERAND (this) = Operand;
  MONOP_OP (this) = Op;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((MONOP_OPERAND (this) != NULL)
      && (NODE_TYPE (MONOP_OPERAND (this)) != N_binop)
      && (NODE_TYPE (MONOP_OPERAND (this)) != N_monop)
      && (NODE_TYPE (MONOP_OPERAND (this)) != N_funcall)
      && (NODE_TYPE (MONOP_OPERAND (this)) != N_cast)
      && (NODE_TYPE (MONOP_OPERAND (this)) != N_var)
      && (NODE_TYPE (MONOP_OPERAND (this)) != N_num)
      && (NODE_TYPE (MONOP_OPERAND (this)) != N_float)
      && (NODE_TYPE (MONOP_OPERAND (this)) != N_bool)
      && (NODE_TYPE (MONOP_OPERAND (this)) != N_arrexpr))
    {
      CTIwarn ("Field Operand of node N_MonOp has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_VarLet :
 *****************************************************************************/

node *
TBmakeVarlet (char *Name, node * Decl, node * Indices)
{
  node *this;
  DBUG_ENTER ("TBmakeVarlet");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_varlet;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_varlet = MEMmalloc (sizeof (struct SONS_N_VARLET));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_varlet = MEMmalloc (sizeof (struct ATTRIBS_N_VARLET));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_varlet;
  DBUG_PRINT ("MAKE", ("assigning son Indices initial value: %s ", Indices));
  VARLET_INDICES (this) = Indices;
  VARLET_NAME (this) = Name;
  VARLET_DECL (this) = Decl;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((VARLET_INDICES (this) != NULL)
      && (NODE_TYPE (VARLET_INDICES (this)) != N_exprs))
    {
      CTIwarn ("Field Indices of node N_VarLet has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Var :
 *****************************************************************************/

node *
TBmakeVar (char *Name, node * Decl, node * Indices)
{
  node *this;
  DBUG_ENTER ("TBmakeVar");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_var;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_var = MEMmalloc (sizeof (struct SONS_N_VAR));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_var = MEMmalloc (sizeof (struct ATTRIBS_N_VAR));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_var;
  DBUG_PRINT ("MAKE", ("assigning son Indices initial value: %s ", Indices));
  VAR_INDICES (this) = Indices;
  VAR_NAME (this) = Name;
  VAR_DECL (this) = Decl;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((VAR_INDICES (this) != NULL)
      && (NODE_TYPE (VAR_INDICES (this)) != N_exprs))
    {
      CTIwarn ("Field Indices of node N_Var has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Num :
 *****************************************************************************/

node *
TBmakeNum (int Value)
{
  node *this;
  DBUG_ENTER ("TBmakeNum");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_num;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_num = MEMmalloc (sizeof (struct SONS_N_NUM));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_num = MEMmalloc (sizeof (struct ATTRIBS_N_NUM));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_num;
  NUM_VALUE (this) = Value;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Float :
 *****************************************************************************/

node *
TBmakeFloat (float Value)
{
  node *this;
  DBUG_ENTER ("TBmakeFloat");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_float;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_float = MEMmalloc (sizeof (struct SONS_N_FLOAT));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_float = MEMmalloc (sizeof (struct ATTRIBS_N_FLOAT));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_float;
  FLOAT_VALUE (this) = Value;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Bool :
 *****************************************************************************/

node *
TBmakeBool (bool Value)
{
  node *this;
  DBUG_ENTER ("TBmakeBool");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_bool;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_bool = MEMmalloc (sizeof (struct SONS_N_BOOL));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_bool = MEMmalloc (sizeof (struct ATTRIBS_N_BOOL));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_bool;
  BOOL_VALUE (this) = Value;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Error :
 *****************************************************************************/

node *
TBmakeError (char *message, compiler_phase_t anyphase, node * Next)
{
  node *this;
  DBUG_ENTER ("TBmakeError");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_error;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_error = MEMmalloc (sizeof (struct SONS_N_ERROR));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_error = MEMmalloc (sizeof (struct ATTRIBS_N_ERROR));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_error;
  DBUG_PRINT ("MAKE", ("assigning son Next initial value: %s ", Next));
  ERROR_NEXT (this) = Next;
  ERROR_MESSAGE (this) = message;
  ERROR_ANYPHASE (this) = anyphase;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((ERROR_NEXT (this) != NULL)
      && (NODE_TYPE (ERROR_NEXT (this)) != N_error))
    {
      CTIwarn ("Field Next of node N_Error has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

  /* end of file */
